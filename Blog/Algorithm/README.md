## ✅ 1. Sliding Window (Cửa sổ trượt)

Dùng để thực hiện các thao tác trên một khoảng cố định của mảng hoặc danh sách liên kết, ví dụ tìm dãy con dài nhất thỏa mãn điều kiện. Kích thước cửa sổ có thể thay đổi tùy bài toán.

---

## ✅ 2. Two Pointers (Hai con trỏ)

Phù hợp khi so sánh các phần tử trong mảng hoặc danh sách đã sắp xếp. Hai con trỏ cùng duyệt dữ liệu, giảm độ phức tạp thời gian so với việc sử dụng một con trỏ.

---

## ✅ 3. Fast and Slow Pointers (Con trỏ nhanh và chậm)

Thường dùng với danh sách liên kết hoặc cấu trúc vòng lặp. Con trỏ nhanh và chậm sẽ gặp nhau nếu tồn tại chu kỳ, giúp phát hiện vòng lặp hiệu quả.

---

## ✅ 4. Merge Intervals (Gộp khoảng)

Giải quyết các bài toán liên quan đến khoảng chồng lấn. Hiểu rõ 6 trường hợp chồng lấn giữa hai khoảng để xử lý hợp nhất hoặc chèn khoảng.

---

## ✅ 5. Cyclic Sort (Sắp xếp vòng lặp)

Dùng cho các mảng chứa số trong một phạm vi xác định. Duyệt từng phần tử và đặt chúng về đúng vị trí để đạt độ phức tạp O(n).

---

## ✅ 6. In-Place Reversal of Linked List (Đảo ngược danh sách liên kết tại chỗ)

Đảo ngược danh sách mà không cần sử dụng bộ nhớ bổ sung. Sử dụng hai biến con trỏ (current và previous) để thực hiện thao tác.

---

## ✅ 7. Tree BFS (Duyệt cây theo chiều rộng)

Duyệt cây theo từng tầng bằng cách sử dụng hàng đợi. Thích hợp cho các bài toán yêu cầu truy cập cây theo mức.

---

## ✅ 8. Tree DFS (Duyệt cây theo chiều sâu)

Duyệt cây theo thứ tự tiền tố, trung tố, hoặc hậu tố. Sử dụng đệ quy hoặc stack để lưu trữ các nút đã duyệt.

---

## ✅ 9. Two Heaps (Hai heap)

Phân chia dữ liệu thành hai phần: Min Heap cho phần lớn nhất và Max Heap cho phần nhỏ nhất. Thường dùng trong bài toán tìm median hoặc top-k phần tử.

---

## ✅ 10. Subsets (Tập con)

Tạo tập con từ một tập hợp cho trước bằng cách áp dụng BFS. Bắt đầu từ tập rỗng và thêm lần lượt từng phần tử để tạo tập con mới.

---

## ✅ 11. Modified Binary Search (Tìm kiếm nhị phân mở rộng)

Dùng khi làm việc với dữ liệu đã sắp xếp. Tránh lỗi tràn số nguyên với công thức middle = start + (end - start) / 2.

---

## ✅ 12. Top K Elements (K phần tử lớn nhất/nhỏ nhất)

Sử dụng heap để tìm các phần tử lớn nhất, nhỏ nhất, hoặc xuất hiện thường xuyên nhất trong tập dữ liệu. Liên tục duy trì heap với các phần tử phù hợp.

---

## ✅ 13. K-Way Merge (Hợp nhất K dãy)

Xử lý nhiều mảng đã sắp xếp bằng cách sử dụng Min Heap để hợp nhất. Lần lượt lấy phần tử nhỏ nhất từ heap và thay thế bằng phần tử tiếp theo từ mảng tương ứng.

---

## ✅ 14. Topological Sort (Sắp xếp topo)

Sắp xếp các phần tử có mối quan hệ phụ thuộc theo thứ tự tuyến tính. Dùng danh sách kề và in-degree để xác định và xử lý các

Thường dùng với danh sách liên kết hoặc cấu trúc vòng lặp. Con trỏ nhanh và chậm sẽ gặp nhau nếu tồn tại chu kỳ, giúp phát hiện vòng lặp hiệu quả.

---

## 4. Merge Intervals (Gộp khoảng)

Giải quyết các bài toán liên quan đến khoảng chồng lấn. Hiểu rõ 6 trường hợp chồng lấn giữa hai khoảng để xử lý hợp nhất hoặc chèn khoảng.

---

## 5. Cyclic Sort (Sắp xếp vòng lặp)

Dùng cho các mảng chứa số trong một phạm vi xác định. Duyệt từng phần tử và đặt chúng về đúng vị trí để đạt độ phức tạp O(n).

---

## 6. In-Place Reversal of Linked List (Đảo ngược danh sách liên kết tại chỗ)

Đảo ngược danh sách mà không cần sử dụng bộ nhớ bổ sung. Sử dụng hai biến con trỏ (current và previous) để thực hiện thao tác.

---

## 7. Tree BFS (Duyệt cây theo chiều rộng)

Duyệt cây theo từng tầng bằng cách sử dụng hàng đợi. Thích hợp cho các bài toán yêu cầu truy cập cây theo mức.

---

## 8. Tree DFS (Duyệt cây theo chiều sâu)

Duyệt cây theo thứ tự tiền tố, trung tố, hoặc hậu tố. Sử dụng đệ quy hoặc stack để lưu trữ các nút đã duyệt.

---

## 9. Two Heaps (Hai heap)

Phân chia dữ liệu thành hai phần: Min Heap cho phần lớn nhất và Max Heap cho phần nhỏ nhất. Thường dùng trong bài toán tìm median hoặc top-k phần tử.

---

## 10. Subsets (Tập con)

Tạo tập con từ một tập hợp cho trước bằng cách áp dụng BFS. Bắt đầu từ tập rỗng và thêm lần lượt từng phần tử để tạo tập con mới.

---

## 11. Modified Binary Search (Tìm kiếm nhị phân mở rộng)

Dùng khi làm việc với dữ liệu đã sắp xếp. Tránh lỗi tràn số nguyên với công thức middle = start + (end - start) / 2.

---

## 12. Top K Elements (K phần tử lớn nhất/nhỏ nhất)

Sử dụng heap để tìm các phần tử lớn nhất, nhỏ nhất, hoặc xuất hiện thường xuyên nhất trong tập dữ liệu. Liên tục duy trì heap với các phần tử phù hợp.

---

## 13. K-Way Merge (Hợp nhất K dãy)

Xử lý nhiều mảng đã sắp xếp bằng cách sử dụng Min Heap để hợp nhất. Lần lượt lấy phần tử nhỏ nhất từ heap và thay thế bằng phần tử tiếp theo từ mảng tương ứng.

---

## 14. Topological Sort (Sắp xếp topo)

Sắp xếp các phần tử có mối quan hệ phụ thuộc theo thứ tự tuyến tính. Dùng danh sách kề và in-degree để xác định và xử lý
2Two Pointers (Hai con trỏ)
Phù hợp khi so sánh các phần tử trong mảng hoặc danh sách đã sắp xếp. Hai con trỏ cùng duyệt dữ liệu, giảm độ phức tạp thời gian so với việc sử dụng một con trỏ.
Fast and Slow Pointers (Con trỏ nhanh và chậm)
Thường dùng với danh sách liên kết hoặc cấu trúc vòng lặp. Con trỏ nhanh và chậm sẽ gặp nhau nếu tồn tại chu kỳ, giúp phát hiện vòng lặp hiệu quả.
Merge Intervals (Gộp khoảng)
Giải quyết các bài toán liên quan đến khoảng chồng lấn. Hiểu rõ 6 trường hợp chồng lấn giữa hai khoảng để xử lý hợp nhất hoặc chèn khoảng.
Cyclic Sort (Sắp xếp vòng lặp)
Dùng cho các mảng chứa số trong một phạm vi xác định. Duyệt từng phần tử và đặt chúng về đúng vị trí để đạt độ phức tạp O(n).
In-Place Reversal of Linked List (Đảo ngược danh sách liên kết tại chỗ)
Đảo ngược danh sách mà không cần sử dụng bộ nhớ bổ sung. Sử dụng hai biến con trỏ (current và previous) để thực hiện thao tác.
Tree BFS (Duyệt cây theo chiều rộng)
Duyệt cây theo từng tầng bằng cách sử dụng hàng đợi. Thích hợp cho các bài toán yêu cầu truy cập cây theo mức.
Tree DFS (Duyệt cây theo chiều sâu)
Duyệt cây theo thứ tự tiền tố, trung tố, hoặc hậu tố. Sử dụng đệ quy hoặc stack để lưu trữ các nút đã duyệt.
Two Heaps (Hai heap)
Phân chia dữ liệu thành hai phần: Min Heap cho phần lớn nhất và Max Heap cho phần nhỏ nhất. Thường dùng trong bài toán tìm median hoặc top-k phần tử.
Subsets (Tập con)
Tạo tập con từ một tập hợp cho trước bằng cách áp dụng BFS. Bắt đầu từ tập rỗng và thêm lần lượt từng phần tử để tạo tập con mới.
Modified Binary Search (Tìm kiếm nhị phân mở rộng)
Dùng khi làm việc với dữ liệu đã sắp xếp. Tránh lỗi tràn số nguyên với công thức middle = start + (end - start) / 2.
Top K Elements (K phần tử lớn nhất/nhỏ nhất)
Sử dụng heap để tìm các phần tử lớn nhất, nhỏ nhất, hoặc xuất hiện thường xuyên nhất trong tập dữ liệu. Liên tục duy trì heap với các phần tử phù hợp.
K-Way Merge (Hợp nhất K dãy)
Xử lý nhiều mảng đã sắp xếp bằng cách sử dụng Min Heap để hợp nhất. Lần lượt lấy phần tử nhỏ nhất từ heap và thay thế bằng phần tử tiếp theo từ mảng tương ứng.
Topological Sort (Sắp xếp topo)
Sắp xếp các phần tử có mối quan hệ phụ thuộc theo thứ tự tuyến tính. Dùng danh sách kề và in-degree để xác định và xử lý các nút nguồn.
